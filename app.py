#importing all the libraries
import streamlit as st
from streamlit_lottie import st_lottie
import json
import pandas as pd
import numpy as np
import altair as alt
import joblib
import base64
from textblob import TextBlob
from fpdf import FPDF
import datetime
import os
import tempfile
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from matplotlib import pyplot as plt
import speech_recognition as sr
import time
import plotly.express as px
from chatbot import get_chatbot_response
from music_suggester import get_music_suggestion
from history import save_to_history, load_user_history




# Loading the logo
with open("tonosense-removebg-preview.png", "rb") as image_file:
    logo_base64 = base64.b64encode(image_file.read()).decode()

#page configuration
st.set_page_config(
    page_title="TonoSense | Emotion & Sentiment Analyzer",
    page_icon="üß†",
    layout="centered",
    initial_sidebar_state="collapsed"
)

def reshape_column(x):
    return x.values.reshape(-1, 1)

pipe_lr = joblib.load(open("text_emotion.pkl", "rb"))
sentiment_pipe = joblib.load(open("reviews_sentiment_with_textblob.pkl", "rb"))

#emojis dictionary
emotions_emoji_dict = {
    "anger": "üò†",
    "fear": "üò®",
    "joy": "üòÇ",
    "love": "‚ù§Ô∏è",
    "sadness": "üòî",
    "surprise": "üòÆ"
}

sentiment_emoji_dict = {
    "positive": "üòä",
    "negative": "üòû",
    "neutral": "üòê"
}

def predict_emotions(docx):
    return pipe_lr.predict([docx])[0]

def get_prediction_proba(docx):
    return pipe_lr.predict_proba([docx])

def predict_sentiment(text):
    polarity = TextBlob(text).sentiment.polarity
    subjectivity = TextBlob(text).sentiment.subjectivity
    input_df = pd.DataFrame([{'Text': text, 'Polarity': polarity, 'Subjectivity': subjectivity}])
    return sentiment_pipe.predict(input_df)[0]

def get_sentiment_proba(text):
    polarity = TextBlob(text).sentiment.polarity
    subjectivity = TextBlob(text).sentiment.subjectivity
    input_df = pd.DataFrame([{'Text': text, 'Polarity': polarity, 'Subjectivity': subjectivity}])
    return sentiment_pipe.predict_proba(input_df)

from fpdf import FPDF
import tempfile
import os
import datetime
import matplotlib.pyplot as plt

#pdf downloading
def export_to_pdf(user_name, user_text, prediction, confidence, analysis_type, proba_df):
    from fpdf import FPDF
    import datetime
    import tempfile
    import os
    import matplotlib.pyplot as plt

    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()

    # --- Black background header ---
    pdf.set_fill_color(0, 74, 173)  # Deep blue
    pdf.rect(0, 0, 210, 40, 'F')

    pdf.set_text_color(255, 255, 255)
    pdf.set_font("Times", 'B', 20)
    pdf.cell(0, 10, "TonoSense Report", ln=True, align='C')
    pdf.ln(10)

    #Reset text color
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Times", '', 12)

    #User Info
    pdf.cell(0, 10, f"Name: {user_name}", ln=True)
    pdf.cell(0, 10, f"Analysis Type: {analysis_type}", ln=True)
    pdf.cell(0, 10, f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True)
    pdf.ln(5)

    #Input Text
    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Input Text:", ln=True)
    pdf.set_font("Times", '', 12)
    pdf.multi_cell(0, 8, user_text)
    pdf.ln(5)

    #Prediction
    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Prediction Result:", ln=True)
    pdf.set_font("Times", '', 12)
    pdf.cell(0, 10, f"Prediction: {prediction}", ln=True)
    pdf.cell(0, 10, f"Confidence: {confidence:.2f}", ln=True)
    pdf.ln(5)

    #Chart
    chart_path = os.path.join(tempfile.gettempdir(), "proba_chart.png")
    plt.figure(figsize=(5, 3))
    plt.bar(proba_df.iloc[:, 0], proba_df.iloc[:, 1], color='#004aad')
    plt.title("Prediction Probabilities")
    plt.xlabel("Class")
    plt.ylabel("Probability")
    plt.tight_layout()
    plt.savefig(chart_path)
    plt.close()

    pdf.set_font("Times", 'BI', 14)
    pdf.cell(0, 10, "Probability Chart:", ln=True)
    pdf.image(chart_path, w=150)
    pdf.ln(10)

    #Footer
    pdf.set_font("Times", 'I', 10)
    pdf.cell(0, 10, "Generated by TonoSense | Powered by Streamlit & Python", ln=True, align='C')

    #Save
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = user_name.replace(" ", "_")
    pdf_path = os.path.join(tempfile.gettempdir(), f"{safe_name}_TonoSense_Report_{timestamp}.pdf")
    pdf.output(pdf_path)

    return pdf_path

#feedback
def submit_feedback(name, email, feedback_text):
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds_json = st.secrets["google"]["credentials"]
    creds = ServiceAccountCredentials.from_json_keyfile_dict(json.loads(creds_json), scope)
    client = gspread.authorize(creds)
    sheet = client.open("TonoSense").sheet1

    # Append feedback row
    sheet.append_row([
        datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        name,
        email,
        feedback_text
    ])
    return True

#voice
def transcribe_voice():
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        st.info("üéôÔ∏è Listening... Please speak clearly")
        audio = recognizer.listen(source, phrase_time_limit=10)
        try:
            return recognizer.recognize_google(audio)
        except sr.UnknownValueError:
            return None
        except sr.RequestError:
            return None

def load_lottiefile(filepath: str):
    with open(filepath, "r") as f:
        return json.load(f)

# MAIN 
def main():
    st.markdown(f"""
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

html, body, [class*="css"] {{
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(180deg, #0a1a2f 0%, #0a1a2f 50%, #0f2235 100%);
  color: #f8f9fa;
}}

.wave-header {{
  position: relative;
  background: radial-gradient(circle at 50% 0%, #498184 0%, #004aad 100%);
  height: 240px;
  text-align: center;
  overflow: hidden;
  border-bottom-left-radius: 50% 10%;
  border-bottom-right-radius: 50% 10%;
  display: flex;
  align-items: center;
  justify-content: center;
}}

.wave-header img.logo {{
  max-width: 380px;
  height: auto;
  z-index: 5;
}}

.wave-header svg.wave {{
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100px;
}}

.icon {{
  position: absolute;
  width: 40px;
  height: 40px;
  opacity: 0.15;
  animation: float 12s ease-in-out infinite;
}}

.icon1 {{ top: 30px; left: 30px; animation-delay: 0s; }}
.icon2 {{ top: 50px; right: 50px; animation-delay: 2s; }}
.icon3 {{ top: 50%; left: 50%; transform: translate(-50%, -50%); animation-delay: 4s; }}
.icon4 {{ top: 40px; right: 100px; animation-delay: 6s; }}
.icon5 {{ bottom: 30px; left: 80px; animation-delay: 8s; }}

@keyframes float {{
  0%   {{ transform: translateY(0); }}
  50%  {{ transform: translateY(-20px); }}
  100% {{ transform: translateY(0); }}
}}

/* --- FORM STYLES --- */
input[type="text"], textarea {{
  width: 100%;
  padding: 10px 14px;
  border: 2px solid #004aad;
  border-radius: 8px;
  background: #0f2235;
  color: #ffffff;
  font-size: 15px;
}}

input[type="text"]:focus, textarea:focus {{
  border-color: #5de0e6;
  outline: none;
  background: #0c1c2e;
}}

div.stButton > button {{
  background: #004aad;
  color: #fff;
  border: none;
  border-radius: 25px;
  padding: 0.6em 1.4em;
  font-weight: 600;
  font-size: 15px;
  transition: 0.3s;
}}

div.stButton > button:hover {{
  background: #5de0e6;
  color: #000;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  cursor: pointer;
}}

/* Smaller logo for mobile */
@media (max-width: 768px) {{
  .wave-header {{ height: 200px; }}
  .wave-header img.logo {{ max-width: 160px; }}
}}

/* Custom spinner style */
div[data-testid="stSpinner"] > div {{
  border: 4px solid #004aad;
  border-top: 4px solid #5de0e6;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 30px auto;
}}

@keyframes spin {{
  0% {{ transform: rotate(0deg); }}
  100% {{ transform: rotate(360deg); }}
}}

div[data-testid="stSpinner"] p {{
  text-align: center;
  font-weight: 600;
  color: #5de0e6;
  margin-top: 60px;
}}
</style>

<!-- FULL WAVE HEADER WITH ICONS & WAVES -->
<div class="wave-header">

  <!-- Floating icons -->
  <div class="icon icon1">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#fff" stroke-width="2" viewBox="0 0 24 24">
      <path d="M14.828 14.828a4 4 0 01-5.656 0M9 9h.01M15 9h.01M12 20a8 8 0 100-16 8 8 0 000 16z"/>
    </svg>
  </div>

  <div class="icon icon2">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#fff" stroke-width="2" viewBox="0 0 24 24">
      <path d="M12 2a7 7 0 00-7 7c0 2.5 1.5 4 2.5 5.5L8 17h8l.5-2.5c1-1.5 2.5-3 2.5-5.5a7 7 0 00-7-7z"/><path d="M9 21h6"/>
    </svg>
  </div>

  <div class="icon icon3">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M12 2l2.4 7.2H22l-5.6 4 2.4 7.2L12 16l-6.8 4.4 2.4-7.2L2 9.2h7.6z"/>
    </svg>
  </div>

  <div class="icon icon4">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M5 12l1-4-4-1 4-1 1-4 1 4 4 1-4 1-1 4zM17 12l1-4-4-1 4-1 1-4 1 4 4 1-4 1-1 4z"/>
    </svg>
  </div>

  <div class="icon icon5">
    <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" viewBox="0 0 24 24">
      <path d="M12 21C12 21 5 14.5 5 9.5C5 6.4 7.4 4 10.5 4C11.7 4 12.9 4.5 13.7 5.3L12 7L10.3 5.3C11.1 4.5 12.3 4 13.5 4C16.6 4 19 6.4 19 9.5C19 14.5 12 21 12 21Z"/>
    </svg>
  </div>

  <!-- Logo centered -->
  <img src="data:image/png;base64,{logo_base64}" alt="Logo" class="logo" />

  <!-- Main wave -->
  <svg class="wave" viewBox="0 0 1440 320" preserveAspectRatio="none">
    <defs>
      <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%" style="stop-color:#498184;stop-opacity:1" />
        <stop offset="90%" style="stop-color:#0a1a2f;stop-opacity:1" />
      </linearGradient>
    </defs>
    <path fill="url(#grad1)" d="M0,192L80,181.3C160,171,320,149,480,138.7C640,128,800,128,960,138.7C1120,149,1280,171,1360,181.3L1440,192L1440,320L0,320Z"></path>
  </svg>

  <!-- Subtle second wave for depth -->
  <svg class="wave" style="bottom:-20px; opacity:0.4;" viewBox="0 0 1440 320" preserveAspectRatio="none">
    <path fill="#004aad" d="M0,224L80,202.7C160,181,320,139,480,117.3C640,96,800,96,960,117.3C1120,139,1280,181,1360,202.7L1440,224L1440,320L0,320Z"></path>
  </svg>
</div>
""", unsafe_allow_html=True)



    if "user_name" not in st.session_state:
        user_name = st.text_input("üë§ Enter your name", placeholder="e.g., Minark")
        if user_name.strip():
            st.session_state.user_name = user_name
            st.session_state.show_splash = True
            st.rerun()
        else:
            st.warning("‚ö†Ô∏è Please enter your name to proceed.")
            return

    elif st.session_state.get("show_splash", False):
        lottie_splash = load_lottiefile("Main Scene.json")
        st_lottie(lottie_splash, speed=1, loop=False, height=500)
        st.info("Loading your personalized workspace... ü§ñ")
        time.sleep(2.5)
        st.session_state.show_splash = False
        st.rerun()

    else:
        # Fade-in for main page
        with st.container():
            st.markdown('<div class="fade-in">', unsafe_allow_html=True)
            show_main_page()
            st.markdown('</div>', unsafe_allow_html=True)

#main page logic
def show_main_page():
    import matplotlib.pyplot as plt
    from wordcloud import WordCloud
    import datetime
    import os
    import pandas as pd
    import io
    import plotly.express as px
    from fpdf import FPDF
    from music_suggester import get_music_suggestion

    user_name = st.session_state.user_name
    st.subheader(f"üéâ Welcome, {user_name}! üëã Ready to analyze text üß†")
    st.info("üí° Tip: Try tweet-length text for better detection")

    st.markdown("<span title='Choose what type of analysis you want to perform'>üìä <b>Choose Analysis Type</b></span>", unsafe_allow_html=True)
    analysis_mode = st.selectbox(" ", ["Sentiment Analysis", "Emotion Detection"])

    st.markdown("### ‚úçÔ∏è Input your text below")
    input_mode = st.radio("Choose input method:", ["Type", "Voice"])

    raw_text = ""
    analyze_now = False

    if input_mode == "Type":
        raw_text = st.text_area("üìù Enter your text", height=150)
        analyze_now = st.button('üîç Analyze')
    else:
        if st.button("üéôÔ∏è Speak Now"):
            transcribed = transcribe_voice()
            if transcribed:
                raw_text = transcribed
                st.success(f"üìù Transcribed Text:\n\n> {transcribed}")
                analyze_now = True
            else:
                st.error("‚ùå Could not transcribe your voice. Please try again.")

    if analyze_now and raw_text.strip():
        with st.spinner("Analyzing your text... üß†"):
            col1, col2 = st.columns(2)

            if analysis_mode == "Emotion Detection":
                prediction = predict_emotions(raw_text)
                probability = get_prediction_proba(raw_text)
                emoji_icon = emotions_emoji_dict.get(prediction, "")
                confidence = np.max(probability)

                st.session_state.predicted_emotion = prediction

                with col1:
                    st.success("Original Text")
                    st.write(raw_text)
                    st.success("Predicted Emotion")
                    st.write(f"{prediction} {emoji_icon} | Confidence: {confidence:.2f}")

                with col2:
                    st.success("Prediction Probabilities")
                    proba_df = pd.DataFrame(probability, columns=pipe_lr.classes_)
                    proba_df_clean = proba_df.T.reset_index()
                    proba_df_clean.columns = ["emotion", "probability"]
                    fig = px.bar(proba_df_clean, x="emotion", y="probability", color="emotion", text="probability", title="Prediction Probabilities")
                    fig.update_traces(texttemplate='%{text:.2f}', textposition='outside', marker_line_width=1.5, opacity=0.8)
                    fig.update_layout(yaxis=dict(range=[0, 1]), transition={'duration': 800}, plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)', font=dict(color='#f8f9fa'))
                    st.plotly_chart(fig, use_container_width=True)

                pdf_path = export_to_pdf(user_name, raw_text, prediction, confidence, analysis_mode, proba_df_clean)


                #music & quote recommendation
                st.subheader("üéß Music & Quote Recommendation")
                suggestion = get_music_suggestion(prediction)
                st.write(f"**üé∂ {suggestion['title']}**")
                st.markdown(f"[‚ñ∂Ô∏è Listen here]({suggestion['url']})")
                st.caption(suggestion['description'])

                current_hour = datetime.datetime.now().hour
                if current_hour < 12:
                    st.info("‚òÄÔ∏è Morning vibes: Start your day with calm focus.")
                elif current_hour < 18:
                    st.info("üåû Afternoon boost: Keep going, you're doing great!")
                else:
                    st.info("üåô Evening mood: Relax and reflect.")

                quotes = {
                    "joy": "Happiness is not something ready-made. It comes from your own actions. ‚Äì Dalai Lama",
                    "sadness": "Tears come from the heart and not from the brain. ‚Äì Leonardo da Vinci",
                    "anger": "Speak when you are angry and you will make the best speech you will ever regret. ‚Äì Ambrose Bierce",
                    "fear": "Do one thing every day that scares you. ‚Äì Eleanor Roosevelt",
                    "love": "To love and be loved is to feel the sun from both sides. ‚Äì David Viscott",
                    "surprise": "Surprise is the greatest gift which life can grant us. ‚Äì Boris Pasternak",
                    "positive": "Keep your face always toward the sunshine‚Äîand shadows will fall behind you. ‚Äì Walt Whitman",
                    "negative": "Even the darkest night will end and the sun will rise. ‚Äì Victor Hugo",
                    "neutral": "Life is a balance of holding on and letting go."
                }
                st.markdown(f"üí¨ **Quote:** _{quotes.get(prediction.lower(), 'Stay positive!')}_")

            else:
                prediction = predict_sentiment(raw_text)
                probability = get_sentiment_proba(raw_text)
                emoji_icon = sentiment_emoji_dict.get(prediction.lower(), "")
                confidence = np.max(probability)

                st.session_state.predicted_sentiment = prediction

                with col1:
                    st.success("Original Text")
                    st.write(raw_text)
                    st.success("Predicted Sentiment")
                    st.write(f"{prediction} {emoji_icon} | Confidence: {confidence:.2f}")

                    if prediction.lower() == "positive":
                        st.balloons()
                    elif prediction.lower() == "negative":
                        st.snow()

                with col2:
                    st.success("Prediction Probabilities")
                    proba_df = pd.DataFrame(probability, columns=sentiment_pipe.classes_)
                    proba_df_clean = proba_df.T.reset_index()
                    proba_df_clean.columns = ["sentiment", "probability"]
                    fig = px.bar(proba_df_clean, x="sentiment", y="probability", color="sentiment", text="probability", title="Prediction Probabilities")
                    fig.update_traces(texttemplate='%{text:.2f}', textposition='outside', marker_line_width=1.5, opacity=0.8)
                    fig.update_layout(yaxis=dict(range=[0, 1]), transition={'duration': 800}, plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)', font=dict(color='#f8f9fa'))
                    st.plotly_chart(fig, use_container_width=True)

                pdf_path = export_to_pdf(user_name, raw_text, prediction, confidence, analysis_mode, proba_df_clean)

                st.subheader("üéß Music & Quote Recommendation")
                suggestion = get_music_suggestion(prediction)
                st.write(f"**üé∂ {suggestion['title']}**")
                st.markdown(f"[‚ñ∂Ô∏è Listen here]({suggestion['url']})")
                st.caption(suggestion['description'])

                current_hour = datetime.datetime.now().hour
                if current_hour < 12:
                    st.info("‚òÄÔ∏è Morning vibes: Start your day with calm focus.")
                elif current_hour < 18:
                    st.info("üåû Afternoon boost: Keep going, you're doing great!")
                else:
                    st.info("üåô Evening mood: Relax and reflect.")

                quotes = {
                    "positive": "The best way to predict your future is to create it. ‚Äì Abraham Lincoln",
                    "negative": "It is during our darkest moments that we must focus to see the light. ‚Äì Aristotle",
                    "neutral": "The art of life is a constant readjustment to our surroundings. ‚Äì Kakuzo Okakura"
                }
                st.markdown(f"üí¨ **Quote:** _{quotes.get(prediction.lower(), 'Keep going, stay strong!')}_")

        # Save to history
        history_file = "history.csv"
        history_entry = {
            "Timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "User": user_name,
            "Text": raw_text,
            "Prediction": prediction,
            "Confidence": round(confidence, 2),
            "Mode": analysis_mode
        }
        
        if os.path.exists(history_file) and os.path.getsize(history_file) > 0:
            history_df = pd.read_csv(history_file)
            history_df = pd.concat([history_df, pd.DataFrame([history_entry])], ignore_index=True)
        else:
            history_df = pd.DataFrame([history_entry])

        history_df.to_csv(history_file, index=False)

        with st.expander("‚òÅÔ∏è Word Cloud from Input Text"):
            st.markdown("Here's a visual of the words you used:")
            wordcloud = WordCloud(width=800, height=400, background_color='black', colormap='plasma' if analysis_mode == "Emotion Detection" else 'cool', max_words=100).generate(raw_text)
            fig_wc, ax_wc = plt.subplots(figsize=(10, 5))
            ax_wc.imshow(wordcloud, interpolation='bilinear')
            ax_wc.axis("off")
            st.pyplot(fig_wc)

        with open(pdf_path, "rb") as f:
            file_name = os.path.basename(pdf_path)
            st.download_button(label="üìÑ üìÖÔ∏è Download PDF Report", data=f, file_name=file_name, mime="application/pdf")

        with st.expander("üìú View Analysis History"):
            if os.path.exists("history.csv") and os.path.getsize("history.csv") > 0:
                history_df = pd.read_csv("history.csv")
            else:
                history_df = pd.DataFrame(columns=["Timestamp", "User", "Text", "Prediction", "Confidence", "Mode"])

            user_history = history_df[history_df["User"] == user_name]

            if not user_history.empty:
                st.dataframe(user_history[::-1])

                freq_df = user_history["Prediction"].value_counts().reset_index()
                freq_df.columns = ["Prediction", "Count"]
                st.markdown("#### üìä Prediction Frequency")
                freq_chart = px.bar(freq_df, x="Prediction", y="Count", color="Prediction", title="Your Prediction Distribution")
                st.plotly_chart(freq_chart, use_container_width=True)
            else:
                st.info("You don't have any saved analyses yet.")

    if "predicted_emotion" in st.session_state:
        with st.expander("üí¨ Chat with TonoSense Bot"):
            st.markdown("**Talk to your emotion-aware assistant!**")
            user_msg = st.text_input("Your message to bot:", key="chat_input_box")
            if st.button("Send to Bot", key="chat_send_btn"):
                if user_msg.strip():
                    emotion = st.session_state.predicted_emotion
                    bot_reply = get_chatbot_response(emotion, user_msg)
                    st.success("ü§ñ TonoSense Bot:")
                    st.write(bot_reply)
                else:
                    st.warning("Please enter something to chat.")

    st.markdown("---")
    with st.expander("üí¨ Leave Feedback"):
        name = st.text_input("Your Name")
        email = st.text_input("Email")
        feedback_text = st.text_area("Feedback")
        if st.button("Submit Feedback"):
            if submit_feedback(name, email, feedback_text):
                st.success("‚úÖ Feedback submitted!")

    st.markdown("<div style='text-align: center; color: gray;'>Built with bugs, fixed with tears, shipped with love üíî‚û°Ô∏è‚ù§Ô∏è | Powered by Minark‚Äôs overthinking ü§îü§Øüí°</div>", unsafe_allow_html=True)

if __name__ == '__main__':
    main()
